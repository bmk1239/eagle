from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ApplicationBuilder, CommandHandler, CallbackQueryHandler, ContextTypes
import subprocess
import os
import time

BOT_TOKEN = "PASTE_YOUR_BOT_TOKEN"
LOG_DIR = "/home/pi/logs"
SCRIPTS_DIR = "/home/pi/scripts"

# ----------------------
# Helper functions
# ----------------------
def get_jobs():
    return [f.replace(".log", "") for f in os.listdir(LOG_DIR) if f.endswith(".log")]

def get_job_command(job):
    crontab = subprocess.getoutput("crontab -l")
    for line in crontab.splitlines():
        if job in line:
            return " ".join(line.split()[5:])
    return None

def update_crontab(job, schedule_dict):
    cmd = get_job_command(job)
    if not cmd:
        return False
    new_schedule = f"{schedule_dict['minute']} {schedule_dict['hour']} {schedule_dict['day']} {schedule_dict['month']} {schedule_dict['weekday']}"
    subprocess.run(f"(crontab -l | grep -v '{cmd}'; echo \"{new_schedule} {cmd}\") | crontab -", shell=True)
    return True

# ----------------------
# Cron state
# ----------------------
cron_temp = {}  # {chat_id: {"job":job,"fields":{field:value}}}

# ----------------------
# Command Handlers
# ----------------------
async def status_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = "üìä Job Status:\n"
    for f in os.listdir(LOG_DIR):
        if f.endswith(".log"):
            path = f"{LOG_DIR}/{f}"
            t = os.path.getmtime(path)
            msg += f"\nüîπ {f.replace('.log','')}\nüïí Last log update: {time.ctime(t)}\n"
    await update.message.reply_text(msg)

async def log_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not context.args:
        await update.message.reply_text("Usage: /log jobname [lines]")
        return
    job = context.args[0]
    lines = 10
    if len(context.args) > 1:
        try:
            lines = int(context.args[1])
        except ValueError:
            await update.message.reply_text("Lines must be integer")
            return
    log_file = f"{LOG_DIR}/{job}.log"
    if not os.path.exists(log_file):
        await update.message.reply_text("‚ùå Log not found")
        return
    output = subprocess.getoutput(f"tail -n {lines} {log_file}")
    await update.message.reply_text(f"üìÑ {job} log (last {lines} lines):\n{output}")

async def run_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not context.args:
        await update.message.reply_text("Usage: /run jobname")
        return
    job = context.args[0]
    cmd = get_job_command(job)
    if not cmd:
        await update.message.reply_text(f"‚ùå Job {job} not found")
        return
    subprocess.Popen(cmd, shell=True)
    await update.message.reply_text(f"‚ñ∂ {job} started!")

async def cron_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if len(context.args) < 6:
        await update.message.reply_text("Usage: /cron <job> <min> <hour> <day> <month> <weekday>")
        return
    job, m, h, d, mo, w = context.args[:6]
    cmd = get_job_command(job)
    if not cmd:
        await update.message.reply_text(f"‚ùå Job {job} not found")
        return
    subprocess.run(f"(crontab -l | grep -v '{cmd}'; echo \"{m} {h} {d} {mo} {w} {cmd}\") | crontab -", shell=True)
    await update.message.reply_text(f"‚è± Schedule updated for {job}")

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = (
        "üìö **Available Commands:**\n\n"
        "/status - Shows last update time of all jobs\n"
        "/log <jobname> [lines] - Show last [lines] of job log (default 10)\n"
        "/run <jobname> - Run a job immediately\n"
        "/cron <jobname> <min> <hour> <day> <month> <weekday> - Update schedule\n\n"
        "üí° **Buttons:**\n"
        "- Status: Show job status\n"
        "- Run: Select a job to run\n"
        "- Log: View last 10 lines of logs\n"
        "- Update-time: Fully button-based cron update with preview\n"
        "- Help: Show this message"
    )
    await update.message.reply_text(msg)

# ----------------------
# Button Interface
# ----------------------
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [InlineKeyboardButton("üìä Status", callback_data="status")],
        [InlineKeyboardButton("‚ñ∂ Run", callback_data="run_menu")],
        [InlineKeyboardButton("üìÑ Log", callback_data="log_menu")],
        [InlineKeyboardButton("‚è± Update-time", callback_data="cron_menu")],
        [InlineKeyboardButton("‚ùì Help", callback_data="help")],
    ]
    if update.message:
        await update.message.reply_text("üìå Bot Menu:", reply_markup=InlineKeyboardMarkup(keyboard))
    else:  # fallback for button callback
        await update.callback_query.edit_message_text("üìå Bot Menu:", reply_markup=InlineKeyboardMarkup(keyboard))

async def button(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data
    chat_id = query.message.chat_id

    # ---------- Status ----------
    if data == "status":
        msg = "üìä Job Status:\n"
        for f in os.listdir(LOG_DIR):
            if f.endswith(".log"):
                path = f"{LOG_DIR}/{f}"
                t = os.path.getmtime(path)
                msg += f"\nüîπ {f.replace('.log','')}\nüïí Last log update: {time.ctime(t)}\n"
        await query.edit_message_text(msg)
        return

    # ---------- Run ----------
    if data == "run_menu":
        jobs = get_jobs()
        keyboard = [[InlineKeyboardButton(job, callback_data=f"run:{job}")] for job in jobs]
        keyboard.append([InlineKeyboardButton("‚¨Ö Back", callback_data="start")])
        await query.edit_message_text("‚ñ∂ Select job to run:", reply_markup=InlineKeyboardMarkup(keyboard))
        return
    if data.startswith("run:"):
        job = data.split(":")[1]
        cmd = get_job_command(job)
        if cmd:
            subprocess.Popen(cmd, shell=True)
            await query.edit_message_text(f"‚ñ∂ {job} started!")
        else:
            await query.edit_message_text(f"‚ùå Job {job} not found")
        return

    # ---------- Log ----------
    if data == "log_menu":
        jobs = get_jobs()
        keyboard = [[InlineKeyboardButton(job, callback_data=f"log:{job}:10")] for job in jobs]
        keyboard.append([InlineKeyboardButton("‚¨Ö Back", callback_data="start")])
        await query.edit_message_text("üìÑ Select job to view last 10 lines of logs:", reply_markup=InlineKeyboardMarkup(keyboard))
        return
    if data.startswith("log:"):
        _, job, lines = data.split(":")
        log_file = f"{LOG_DIR}/{job}.log"
        if os.path.exists(log_file):
            output = subprocess.getoutput(f"tail -n {lines} {log_file}")
            await query.edit_message_text(f"üìÑ {job} log (last {lines} lines):\n{output}")
        else:
            await query.edit_message_text(f"‚ùå Log {job} not found")
        return

    # ---------- Help ----------
    if data == "help":
        await help_command(update, context)
        return

    # ---------- Cron ----------
    if data == "cron_menu":
        jobs = get_jobs()
        keyboard = [[InlineKeyboardButton(job, callback_data=f"cron:{job}")] for job in jobs]
        keyboard.append([InlineKeyboardButton("‚¨Ö Back", callback_data="start")])
        await query.edit_message_text("‚è± Select job to update schedule:", reply_markup=InlineKeyboardMarkup(keyboard))
        return

    if data.startswith("cron:"):
        job = data.split(":")[1]
        cmd = get_job_command(job)
        if not cmd:
            await query.edit_message_text(f"‚ùå Job {job} not found")
            return
        cron_temp[chat_id] = {"job": job, "fields": {"minute":"*","hour":"*","day":"*","month":"*","weekday":"*"}}
        keyboard = [
            [InlineKeyboardButton("Minute", callback_data="cron_field:minute")],
            [InlineKeyboardButton("Hour", callback_data="cron_field:hour")],
            [InlineKeyboardButton("Day", callback_data="cron_field:day")],
            [InlineKeyboardButton("Month", callback_data="cron_field:month")],
            [InlineKeyboardButton("Weekday", callback_data="cron_field:weekday")],
            [InlineKeyboardButton("Preview", callback_data="cron_preview")],
            [InlineKeyboardButton("Apply", callback_data="cron_apply")],
            [InlineKeyboardButton("‚¨Ö Back", callback_data="start")]
        ]
        await query.edit_message_text(f"‚è± Update schedule for {job}:", reply_markup=InlineKeyboardMarkup(keyboard))
        return

    # ---------- Cron Field ----------
    if data.startswith("cron_field:"):
        field = data.split(":")[1]
        if field == "minute":
            values = [str(i) for i in range(0,60)]
        elif field == "hour":
            values = [str(i) for i in range(0,24)]
        elif field == "day":
            values = [str(i) for i in range(1,32)]
        elif field == "month":
            values = [str(i) for i in range(1,13)]
        elif field == "weekday":
            values = [str(i) for i in range(0,7)]
        else:
            return
        keyboard = [ [InlineKeyboardButton(v, callback_data=f"cron_val:{field}:{v}") for v in values[i:i+6]] for i in range(0,len(values),6)]
        keyboard.append([InlineKeyboardButton("‚¨Ö Back", callback_data="cron_menu")])
        await query.edit_message_text(f"Select value for {field}:", reply_markup=InlineKeyboardMarkup(keyboard))
        return

    # ---------- Cron Value ----------
    if data.startswith("cron_val:"):
        _, field, val = data.split(":")
        if chat_id not in cron_temp:
            return
        cron_temp[chat_id]["fields"][field] = val
        keyboard = [
            [InlineKeyboardButton("Minute", callback_data="cron_field:minute")],
            [InlineKeyboardButton("Hour", callback_data="cron_field:hour")],
            [InlineKeyboardButton("Day", callback_data="cron_field:day")],
            [InlineKeyboardButton("Month", callback_data="cron_field:month")],
            [InlineKeyboardButton("Weekday", callback_data="cron_field:weekday")],
            [InlineKeyboardButton("Preview", callback_data="cron_preview")],
            [InlineKeyboardButton("Apply", callback_data="cron_apply")],
            [InlineKeyboardButton("‚¨Ö Back", callback_data="start")]
        ]
        await query.edit_message_text(f"‚úÖ Set {field} = {val}\nNow select another field, Preview, or Apply", reply_markup=InlineKeyboardMarkup(keyboard))
        return

    # ---------- Cron Preview ----------
    if data == "cron_preview":
        if chat_id not in cron_temp:
            return
        fields = cron_temp[chat_id]["fields"]
        job = cron_temp[chat_id]["job"]
        cmd = get_job_command(job)
        preview = f"{fields['minute']} {fields['hour']} {fields['day']} {fields['month']} {fields['weekday']} {cmd}"
        await query.edit_message_text(f"üëÄ Preview for {job}:\n`{preview}`", parse_mode="Markdown", reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("Apply", callback_data="cron_apply")],
            [InlineKeyboardButton("‚¨Ö Back", callback_data="start")]
        ]))
        return

    # ---------- Cron Apply ----------
    if data == "cron_apply":
        if chat_id not in cron_temp:
            return
        job = cron_temp[chat_id]["job"]
        fields = cron_temp[chat_id]["fields"]
        success = update_crontab(job, fields)
        if success:
            await query.edit_message_text(f"‚úÖ Schedule updated for {job}:\n{fields}")
        else:
            await query.edit_message_text(f"‚ùå Failed to update schedule for {job}")
        cron_temp.pop(chat_id)
        return

    # ---------- Back ----------
    if data == "start":
        await start(update, context)

# ----------------------
# Main
# ----------------------
app = ApplicationBuilder().token(BOT_TOKEN).build()

# Command handlers
app.add_handler(CommandHandler("start", start))
app.add_handler(CommandHandler("status", status_command))
app.add_handler(CommandHandler("log", log_command))
app.add_handler(CommandHandler("run", run_command))
app.add_handler(CommandHandler("cron", cron_command))
app.add_handler(CommandHandler("help", help_command))

# Button handler
app.add_handler(CallbackQueryHandler(button))

app.run_polling()
